# -*- coding: utf-8 -*-
"""baseline_with_translation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16_RVdKc5sVCEATQczzQxyRnC7-kwhhYh
"""

import argparse, pandas as pd, numpy as np
from sklearn.model_selection import KFold
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import Ridge
from sklearn.pipeline import make_pipeline
from sklearn.metrics import mean_squared_error
from scipy.stats import pearsonr
import random

# 設定隨機種子，確保結果可重現
def set_seed(seed=42):
    np.random.seed(seed)
    random.seed(seed)

# 計算 Pearson 相關係數
# 如果 y_true 或 y_pred 只有單一值，相關係數無法計算，回傳 0.0
def pearson(y_true, y_pred):
    if len(np.unique(y_true)) < 2 or len(np.unique(y_pred)) < 2:
        return 0.0
    return pearsonr(y_true, y_pred).statistic

# 訓練與評估函式
def train_eval(train_path, dev_path=None, out_pred_path=None):
    set_seed(42)  # 固定隨機種子

    # 讀取訓練資料
    df_tr = pd.read_csv(train_path)
    text = df_tr["text"].astype(str).values  # 文本資料
    y_v = df_tr["valence"].values           # valence 標籤
    y_a = df_tr["arousal"].values           # arousal 標籤

    # 建立 Ridge 回歸模型的管線 (pipeline)，含 TF-IDF 特徵
    model_v = make_pipeline(
        TfidfVectorizer(ngram_range=(1,2), min_df=2, max_features=200000),
        Ridge(alpha=2.0, random_state=42)
    )
    model_a = make_pipeline(
        TfidfVectorizer(ngram_range=(1,2), min_df=2, max_features=200000),
        Ridge(alpha=2.0, random_state=42)
    )

    # 使用 KFold 做 5 折交叉驗證
    kf = KFold(n_splits=5, shuffle=True, random_state=42)
    preds_v = np.zeros(len(df_tr))  # 儲存 valence 預測
    preds_a = np.zeros(len(df_tr))  # 儲存 arousal 預測

    # 開始 KFold 交叉驗證
    for tr_idx, va_idx in kf.split(text):
        # 用訓練折 fit 模型
        model_v.fit(text[tr_idx], y_v[tr_idx])
        model_a.fit(text[tr_idx], y_a[tr_idx])
        # 對驗證折做預測
        preds_v[va_idx] = model_v.predict(text[va_idx])
        preds_a[va_idx] = model_a.predict(text[va_idx])

    # 輸出訓練資料交叉驗證結果
    print("[Train-CV] Valence  Pearson:", round(pearson(y_v, preds_v), 4),
          " MSE:", round(mean_squared_error(y_v, preds_v), 4))
    print("[Train-CV] Arousal  Pearson:", round(pearson(y_a, preds_a), 4),
          " MSE:", round(mean_squared_error(y_a, preds_a), 4))

    # 最後用全部訓練資料重新 fit 模型，以便對開發集或測試集做預測
    model_v.fit(text, y_v)
    model_a.fit(text, y_a)

    # 如果提供了開發集資料，則做預測與評估
    if dev_path:
        df_dev = pd.read_csv(dev_path)
        x_dev = df_dev["text"].astype(str).values
        pv = model_v.predict(x_dev)
        pa = model_a.predict(x_dev)
        # 若開發集有標籤，計算 Pearson 與 MSE
        if "valence" in df_dev and "arousal" in df_dev:
            print("[Dev] Valence   Pearson:", round(pearson(df_dev["valence"].values, pv), 4),
                  " MSE:", round(mean_squared_error(df_dev["valence"].values, pv), 4))
            print("[Dev] Arousal   Pearson:", round(pearson(df_dev["arousal"].values, pa), 4),
                  " MSE:", round(mean_squared_error(df_dev["arousal"].values, pa), 4))
        # 如果指定輸出路徑，將預測結果存成 CSV
        if out_pred_path:
            out = df_dev[["id"]].copy()
            out["valence"] = pv
            out["arousal"] = pa
            out.to_csv(out_pred_path, index=False)
            print(f"[Saved] {out_pred_path}")

# 主程式入口
if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("--train", required=True, help="path to train.csv")
    ap.add_argument("--dev", required=False, help="path to dev.csv (labels optional)")
    ap.add_argument("--out", required=False, help="path to save predictions on dev/test")
    args = ap.parse_args()
    train_eval(args.train, args.dev, args.out)